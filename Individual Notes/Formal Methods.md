# 命题逻辑

## 命题与联结词

- 命题是一个对事物作出确定判断的**陈述语句**。凡判断合理或与事实符合的陈述句称为真命题；而判断不合理或与事实部分不和陈述句称为假命题或假语句。一个命题具有两种可能的取值，为真或为假，它们称为命题的真值，分别用1和0来表示

- 用于表示**确定命题**的数学符号称为**命题常元**，用于表示**不确定命题**的数学符号称为**命题变元**

- 如果一个命题不可再进一步分割，则称其为原子命题或简单命题 

- 复合命题一个或几个原子命题通过联接词所构成的新命题， 是一个陈述句，其真值依赖于构成该命题的各原子命题的真值及联接词


- 非¬：一元联接词，对应自然言语中的“否定”。一个命题P加上非联接词就形成了一个新的命题，记作¬P
- 析取∨：二元联接词，对应自然言语中的”或“。两个命题P和Q通过析取联接词联系在一起，记作P∨Q
- 合取∧：二元联接词，对应自然言语中的”与“。两个命题P和Q通过合取联接词联系在一起，记作P∧Q
- 蕴涵→：二元联接词，对应自然言语中的”如果…则…“。两个命题P和Q通过蕴涵词联系在一起，记作P→Q，其中P称为前件（条件），Q称为后件（结论）。读作P蕴涵Q，或者如果P则Q，或者P是Q的充分条件，或者Q是P的必要条件。只有前件为真且后件为假时蕴含式才为假
- 双蕴涵↔：二元联接词，对应自然言语中的”当且仅当“。P当且仅当Q或P与Q等价
- 实际应用中，可以通过规定联接词的运算优先级来减少命题公式中圆括号的数量
- 一般地，¬，∧ ， ∨、→， ↔的优先级依次由强到弱，∧ 和 ∨之间没有优先级



## 命题公式

- 命题逻辑讨论的对象，是自然言语中命题的形式化描述，命题公式又称为命题语言，是由一些限定的符号遵循一定的规则所构成的符号串
- 如果公式A含有命题变元P1，P2，…Pn,则可将公式A记为A（P1,P2,…,Pn）,并称之为含有n个命题变元的公式
- 命题公式A(P1,P2,…,Pn)中变元P1,P2,….Pn的一组取值称为指派
  - 使公式A(P1,P2,…,Pn)取值为1的指派，称为真指派
  - 使公式A(P1,P2,…,Pn)取值为0的指派，称为假指派
- 对于公式A(P1,P2,…,Pn)，如果在任意指派下均取值为1，则称该公式为重言式或永真式。如果存在使得公式A(P1,P2,…,Pn)取值为1的指派，则称公式A是可满足的，否则称A为不可满足的或永假式
- 对于公式Ф和Ψ ，如果所有使Ф成真的指派必使Ψ成真，则称Ф蕴涵Ψ ，或者Ф永真蕴涵Ψ ，记作Ф ⇒ Ψ（ Ф |= Ψ ）
- 如果公式Ф和Ψ在任意指派下具有相同的真值，则称Ф和Ψ是等值的（语义）或等价的（语义），记作Ф = Ψ或者Ф = Ψ（ Ф ≡ Ψ ）
- Ф ⇒ Ψ当且仅当Ф → Ψ为永真式； Ф =||=Ψ当且仅当Ф ↔ Ψ为永真式：同时如果Ф ⇒ Ψ并且Ψ ⇒ Ф ，则Ф =||= Ψ 
- 对于公式Ф和Ψ ，如果Ф =||=Ψ ，且Ψ具有如下形式：C1∧C2∧…∧CM(C1 ∨C2…∨Cm)其中，Ci(i=1,2,…,m)具有形式L1 ∨L2 ∨…∨Ln(L1∧L2∧…∧Ln),Ci中的Lj（j=1,2,…m）为原子公式或原子公式的非，则称公式Ψ为公式Ф的合取（析取）范式，并称Ci为Ψ的子句，称Li为字句的文字
- P∧(P∨¬Q∨R)∧(¬p∨Q)，P∧Q∧(P∨¬Q)均是合取范式，P∨(P∧¬Q∧R)∨(¬p∧Q)，P∨Q∨(P∧¬Q)均是析取范式
- 对于公式Ф和Ψ ，如果Ψ是Ф的合取（析取）范式， Ψ的每一个子句包含公式Ф的所有原子公式（所有原子公式在各子句中只出现一次），且各个子句都不相同，则称公式Ψ为公式Ф的主合取（析取）范式，或者完全和取（析取）范式



## 自然演绎

- 定义 ：从前提出发，依照科学合理的推论规则，推出结论的过程

- 命题演算，实质上就是反复配合使用基本蕴涵公式，基本等值公式以及推理规则的过程

- 前提公式：Ф1 ,Ф2 ,…,Фn，结论公式：Ψ，记为矢列：Ф1 ,Ф2 ,…,Фn |-Ψ，如果能找到它的证明，称此矢列是有效的

- 当给出一组前提Ф1 ,Ф2 ,…,Фn时，需要推出结论Ψ ，相当于考察是否成立如下蕴涵公式：Ф1 ∧ Ф2,…∧ Фn ⇒ Ψ。
  - 如果上述蕴涵公式成立，那就意味着：当Ф1 ∧ Ф2,…∧ Фn为真时， Ψ必为真。否则，若Ψ为假，则(Ф1 ∧ Ф2,…∧ Фn )→Ψ为假，这与蕴涵公式的假设矛盾，所以，当上述蕴涵公式成立时，若Ф1 ,Ф2 ,…,Фn都为真，则必有Ψ为真。若上述蕴涵公式不成立，则称Ψ为谬误结论

- 自然演绎规则

  ![](https://raw.githubusercontent.com/CorneliusDeng/Markdown-Photos/main/Discrete%20Mathematics/equivalent%20calculation.png)



## 推理规则

- 前提引入规则：在推理过程中，可以根据需要随时引入前提
- 结论引入规则：在推理过程中所得到的中间结论，可作为后续推理的前提
- 置换规则：在推理过程中，命题公式中的部分公式都可以用其等值公式来置换
- 分离规则（假言推理规则）：已知A→B，A，则可得B
- 附加规则：已知A，则可附加B得到A∨B
- 化简规则：已知A∧B，则可得到A或得到B
- 反证规则（拒取式规则）： 已知A→B，¬B，则可得¬A
- 假言三段论规则：已知A→B，B→C，则可得A→C
- 析取三段论规则：已知A∨B，¬B，则可得A
- 构造性二难推理规则：已知A→B，C→D，A∨C，则可得B∨D
- 破坏性二难推理规则：已知A→B，C→D，¬B∨¬D，则可得¬A∨¬C
- 合取引入规则：已知A，B，则可得A∧B



## 逻辑等价

设Ф和Ψ是命题逻辑公式。当且仅当矢列Ф|-Ψ和Ψ |- Ф都是有效的,Ф和Ψ是逻辑等价，用Ф-||-Ψ表示



## 直接/间接证明

- **直接证明法**

  利用前提和等值公式，蕴涵公式的演绎证明

- **间接证明法**

  设有一组前提p1,p2,…pn，需要推出结论Q，即证明：P1∧P2,…∧Pn⇒Q，即证明：P1∧P2,…∧Pn→Q=1，即证明：¬(P1∧P2,…∧Pn) ∨Q=1，即证明：¬(¬(P1∧P2,…∧Pn) ∨Q)=0，即证明：P1∧P2,…∧Pn∧ ¬Q=0

  ⇒**要证明P1,P2,…Pn├Q,可把结论Q的否定¬Q加入到前提中去，然后再证明P1∧P2,…∧Pn∧ ¬Q为永假式**即可。这种证明法也叫间接证明法。

- **归纳推理法** 

  是一种间接证明法，为了证明A├B，从A∧¬B出发将A∧¬B转化为等价的合取范式，并以合取范式中的所有子句构成的集合S（子句集）为基础，进行子句的归结（消去互补对，即字句¬P∨¬Q和P∨R可得归结式¬Q∨R并将该归结式放入S中），重复归结过程直至归结出矛盾式



## 命题逻辑语义/有效性/合理性

- **命题逻辑的语义**

  语义可以简单地看作是数据所对应的现实世界中的事物所代表的概念的含义，以及这些含义之间的关系，是数据在某个领域上的解释和逻辑表示。

  - 语义推导关系 Ф1 ,Ф2 ,…,Фn |= Ψ
    - 命题公式Ф1 ,Ф2 ,…,Фn 都指派为真的指派， Ψ也指派为真

- **命题逻辑的合理性**

  设Ф1 ,Ф2 ,…,Фn 和Ψ是命题逻辑公式。若Ф1 ,Ф2 ,…,Фn |-Ψ是有效的，则Ф1 ,Ф2 ,…,Фn |=Ψ成立。即语法（逻辑）推导成立，则语义推导成立

- **命题逻辑的完备性**

  只要Ф1 ,Ф2 ,…,Фn |=Ψ成立，都存在矢列Ф1 ,Ф2 ,…,Фn |-Ψ的一个自然演绎证明。即语义成立，语法成立



## 范式

怎样确定Ф1 ,Ф2 ,…,Фn |=Ψ？

通过语义上转化公式为“等价的”公式，然后在纯粹语义和算法含义上讨论

对于公式Ф和Ψ ，如果Ф =||=Ψ ，且Ψ具有如下形式：C1∧C2∧…∧CM其中，ci(i=1,2,…,m)具有形式L1 ∨L2 ∨…∨Ln,ci中的Lj（j=1,2,…m）为原子公式或原子公式的非，则称公式Ψ为公式Ф的合取范式（CNF），并称Ci为Ψ的子句，称Li为子句的文字

- **引理**

  文字的析取L1 ∨L2 ∨…∨Lm是有效的当且仅当存在1≦i,j≦m，使得Li是¬Lj

- **快速判断|=Ф有效性的方法**

  如果Ф是CNF式，检查Ф的所有合取Ψk,寻找Ψk中是否有这样的原子，即它们的否定也在Ψk。如果所有的析取都能找到这个样的匹配，那么就有|=Ф

- **等价的CNF的转化方法**

  - **根据Ф的真值表：真值表中赋值为0的行构造一个文字的析取（文字恰好是真值表中那一行句法的相反）**
  - 等价转化算法
    - 将Ф中的具有形式消去Ф中的蕴涵联接词Ψ→η用¬Ψ∨η替代
    - 消去Ф中的蕴涵联接词将¬ Ф转化为只包含原子否定的等价公式
    - 通过前两步处理完毕的公式输入CNF算法，CNF算法输出一个等价的CNF公式。



# 谓词逻辑

## 基本概念

谓词逻辑，对命题逻辑中的原子命题进行了进一步的分解和细化，通过引入谓词，函词，量词，弥补了自然语言逻辑推理不精确的缺陷。

- **个体域**

  - 任何科学理论都有它的研究对象，这些研究对象构成的一个非空集合称为论域或个体域，以D表示
  - 论域或者个体域中的任一元素称为个体
  - 命题描述个体的部分称为个体词
  - 个体词可以为个体域中的某一确定的个体，也可以泛指个体域中任意元素，前者称为个体常元，后者称为个体变元或者个体变量。一般，个体变量用小写字母表示。

- **函词**

  - 又称为函数，是个体域到个体域上的映射，用小写字母表示 。eg. m(x):x的母亲
  - 函词以一个或一个以上个体变元为变量，包含有一个（n个）个体变元的函词，称为一元（n元）函词。eg. f(x1,x2,…,xn)

- **谓词**

  - 命题中描述个体的特征及个体之间关系的部分称为谓词，以大写字母表示。
  - 对于确定的谓词的符号表示称为谓词常元，否则，称为谓词变元
  - 谓词和个体的结合使用构成命题，一个谓词中可以有一个或者一个以上个体或者函词
  - 对应于含有n个个体函词的谓词称为n元谓词，以P(.,.,…,.)表示
  - 一般地，一元谓词表述了个体的性质，多元谓词表述了个体之间的关系。eg. H(x):x是人；L(x,y)：x>y
  - 注意：谓词不是命题，只有当确定的个体词或者函词“填入”后，才成为命题，一元谓词需要填入一个个体词或函词，n元谓词需要填入n个个体词或函词后才成为命题。对于已有确定真假值的命题可看作为0元谓词。

- **谓词和函词的区别**

  - 函词中的个体变元用个体带入后的结果依然是个体。eg. m(a)=小王的母亲
  - 谓词中的个体变元用确定的个体带入后就变成了命题。eg. M(x)：x是人；M(a)：小王是人
  - 函词是论域到论域的映射，f:D→D
  - 谓词是论域到{T,F}的映射，M:D →{T,F}

- **项**

  - 项是由个体常量，变量和作用其上的函数构成
  - 个体常量是项，个体变元是项
  - 如果f是一个n(n≧1)元函词，其t1, t2,…, tn是项，则f(t1, t2,…, tn)是项

- **量词**

  - 用来表示个体数量的词称为量词，也可看为对个体词所加的限制，约束的词

  - 量词包括存在量词和全称量词

    - 存在量词表示至少存在论域中的一个个体，用“∃x”来表示

    - 全称量词表示论域中的所有，以“∀x“表示

      

## 谓词公式

- **命题函数**
  - 填入个体变元或者函词后的谓词，称为命题函数，如P(x),Q(x,y,z)以及包含有二元函词f(y,z)的P(x,f(y,z),w)
- **原子公式**
  - 若P是一个n元谓词，且t1, tn,…, tn是项，则P(t1, t2,…, tn)是原子
  - 命题词也是原子（n=0）
- **谓词合适公式**
  - 原子命题（命题常元或者命题变元），原子公式是合适公式
  - 如果A,B是合适公式，那么¬A， (A ∧B)、(A ∨ B)、(A → B) 和 (A ↔ B) 是合适公式
  - 如果A是合适公式，x是A中出现的变量（个体变元），则∀xA，∃xA也是合适公式
  - 当且仅当有限次地使用（1）（2）（3）所组成的符号串是合适公式
- **命题符号化**
  - 谓词逻辑比较复杂，命题的符号表达式与论域有关
  - eg1.不是所有的鸟都可以飞翔
    - B(x):x是一只鸟，F(x)：x可以飞翔
    - ¬(∀x B(x)→F(x)）或 ∃x(B(x)∧¬F(x))
  - eg2.每个孩子都比其母亲年轻
    - C(x)：x是一个小孩，m(x)：x的母亲，Y(x,y):x比y年轻
    - ∀x(C(x)→Y(x,m(x)))
  - eg3.所有的大学生都喜欢一些歌星
    - S(x)：x是大学生，X(x)：x是歌星，L(x,y):x喜欢y
    - ∀x(S(x)→∃y(X(y)∧L(x,y)))

## 谓词逻辑应用

- **开关切换系统** 
  - 考察一个切换开关的状态的谓词逻辑描述问题
  - 在不同的时刻开关只能处于“开“或者”关“的状态，并且在某一确定时刻只能处于其中的一种状态
    - switch_on(x):表示在时刻x开关处于”开”的状态
    - switch_off(x)表示在时刻x开关处于和“关”的状态
    - 个体变元x对应于离散的时间
    - 假定论域为一个自然数集合
  - 用谓词on(x,y)表示开关在时刻x,x+1,…,y-1都处于“开”态。谓词off(x,y)表示开关在时刻x,x+1,…,y-1都处于“关”状态，谓词lessthan(x,y)表示x小于y
    - On(x,y) ↔switch_on(x)∧¬(∃z)(lessthan(x,z)∧lessthan(z,y)∧switch_off(z)
    - off(x,y) ↔switch_off(x)∧¬(∃z)(lessthan(x,z)∧lessthan(z,y)∧switch_on(z)
  - 若开关在时刻y处于开（关）状态，而在此之前处于同样的状态的时刻为x，则在x与y之间的所有时刻，开关都一直处于关（开）状态
    - ∀x∀y(switch_on(x)∧switch_on(y)∧lessthan(x,y))∧¬∃z.(switch_on(z)∧lessthan(x,z)∧lessthan(z,y)) ⇒off(x+1,y)
    - ∀x∀y(switch_off(x)∧switch_off(y)∧lessthan(x,y))∧¬∃z.(switch_off(z)∧lessthan(x,z)∧lessthan(z,y)) ⇒on(x+1,y)
  - 用谓词from_off_to_on(u1,v2)表示在u1时刻处于关状态，在v2时刻处于开状态。
    - 其中u1<v2,并且在时刻u1,u1+1,…,v2-1开关一直保持关状态；
    - 或者对于间隔（u1,v2）中的每一时刻，当开关出现开状态后，下一个状态一定为关。
  - 谓词off_on(u1,v2)表示每次开关出现开状态后，下一个状态一定为关;
    谓词on_off(u1,v2) 表示每次开关出现关状态后，下一个状态一定为开；那么
    - Off_on(u1,v2) ↔∃v1. ∃u2(lessthan(u1,v1)∧lessthan(v1,u2)∧lessthan(u2,v2)∧off(u1,v1)∧off(u2,v2)∧on_off(v1,u2)
    - on_off(v1,u3) ↔∃u2. ∃v2.(lessthan(v1,u2)∧lessthan(u2,v2)∧lessthan(v2,u3)∧on(v1,u1)∧on(v2,u3)∧off_on(u2,v2)
    - from_off_to_on(x,y) ↔switch_on(y)∧(off(x,y)∨off_on(x,y));	from_on_to_off(x,y) ↔switch_off(y)∧(on(x,y)∨on_off(x,y))
- **文件操作系统**
  - 考察由记录（Record）的线性序列所组成文件的操作问题
    - 文件中的记录从零开始顺序编号，即，file0,file1,…filek-1是任意一个文件的k个记录。其中fliej（0≤j≤k-1）表示文件的第j个记录
    - 如果k<1，则文件为空。编辑人员可以通过插入，删除和替换来对文件进行修改
  - 如果S(x)是一个关于x的不变的条件，x’表示操作后更新的变量x，S(x’)表述了在操作后状态的不变性
    - 设Position：当前的指针位置，表示了两个相邻记录之间的位置，LP：在position的左边的记录序列，RP：在position的右边的记录序列，Length：文件中的记录数。
    - 位置不变性S(position):0≤position≤length，任意操作对position进行作用后，S(position’)恒为真。
  - 文件操作：		
    - EMPTY_FILE    Position=0∧length=0
    - MOVE_LEFT    指针移动到前一个记录的左端；对于空文件，该操作无效果；
      - 前置条件：position>0
      - 后置条件：(position’=position-1)∧(length’=length)∧(file’=file)
    - MOVE_RIGHT  指针移动到下一个记录的右端；如果当前指针已经在最后一个记录的右端，则该操作不产生影响；
      - 前置条件：position<length
      - 后置条件：(position’=position+1)∧(length’=length)∧(file’=file)
    - INSERT_RIGHT  在文件中插入一个新记录r，从而在新位置左端的记录序列为{LP},右端的记录序列为{r,RP};
      - 后置条件：(position’=position)∧(length’=length+1)∧(∀p)((0≤p<position) → filep’= filep ∧(p=position) → filep’=r∧(position<p<length) → filep+1’= filep
    - INSERT_LEFT  在文件中插入一个新记录r，从而在新位置左端的记录序列为{LP,r},右端的记录序列为{RP};
      - 前置条件：position≧0
      - 后置条件：(position’=position+1)∧(length’=length+1)∧(∀p)((0≤p<position) → filep’= filep∧(p=position) →file’p=r∧(position<p<length) → filep+1’= filep
    - DELETE_LEFT 删除指针左边的记录r；如果当前指针在第一个记录的左端，或者文件为空，则操作不产生影响；
      - 前置条件：前置条件  position≧0
      - 后置条件：(position’=position-1)   ∧(length’=length-1)    ∧ (∀p) ((0≤p<position) → filep ’= filep ∧(position’≤p<length’) → filep ’= filep＋1 )
    - DELETE_RIGHT  删除指针右边的记录r；如果当前指针在第一个记录的右端，或者文件为空，则操作不产生影响；
      - 前置条件： 0≤position<lenght
      - 后置条件：(position’=position)   ∧(length’=length-1)   ∧(∀p)((0≤p<position) → filep’= filep∧(position’≤p<length’) → filep’= filep+1) 
- **有向图的可达性分析**
  - 有向图是一个二元组（V,E），V:一个有限顶点集合，E:一个有限有向边集合
  - 定义谓词
    - 对每个顶点v∈V，谓词vertex(v)为真
    - 对每条边e∈E，谓词edge(e)为真
    - first(x,e)和second(y,e)：边e是从顶点x到顶点y
    - path(x,y)：存在一条从顶点x到顶点y的路径
  - 顶点和边的规格 
    - ∀x(vertex(x)∨edge(x))
    - ∀x¬(vertex(x)∧edge(x))
    - ∀e(edge(e) →(∃x)(∃y)(vertex(x)∧vertex(y)∧first(x,e)∧second(y, e))
  - 路径
    - ∀x∀y∃e(first(x,e)∧second(y,e) →path(x,y))
    - ∀x∀y∃z(path(x,z)∧path(z,y) →path(x,y))
  - 可达性
    - ∀x：R.p表示对集合R中的任何元素，属于p为真；∃x：R.p表示集合R中的存在一个元素，使得属性p为真 
    - ∀v1,v2:V.(path(v1,v2)∧path(v2,v1))，该图为强连通图
    - ∃v1,v2:V.(path(v1,v2)∨path(v2,v1))，该图为非强连通图

## 谓词逻辑演算

- **自由（约束）变元**
  - 对于公式A中的变元x，如果x位于量词∀x或者∃x的作用范围之内，则称x为约束变元，否则，称x为自由变元
    - 谓词公式∀x(P(x) ∧Q(x,y))中，所有x的出现均为约束变元，y为自由变元
    - 谓词公式∃xP(x) ∧(∀y)Q(x,y)中，y为约束变元，x在P(x)中的出现为约束变元，x在Q(x,y)中的出现为自由变元
- **谓词公式的解释**
  - 在已知论域下，谓词公式中所含命题变元，自由个体变元，谓词变元以及函词的一个具体设定，称为谓词公式的一个解释
    - 指定一个论域D
    - 对A中出现的每一个n元函数，指定一个D上的n元个体函数常量
    - 对A中出现的每一个n元谓词，指定一个D上的n元谓词常量
    - 对A中出现的每一个个体变量及自由变元，指定D中的一个个体常量
    - 对A中出现的每一个命题变元P，指定一个真值T或F
  - 由此得到一个命题AI，称AI的真值为合适公式A在解释I下的真值
- **前束范式**
  - 如果谓词公式A中的所有量词都位于该公式的最左边，且这些量词的作用范围都延伸到公式的末端，则称其为前束范式
    - 即前束范式有如下形式：Q1x1Q2x2.…. QmxnM( x1, x2,…, xn)，其中，Qi(i＝1,2,…,m)(m≤n)为量词∃或∀；M(x1, x2,…, xn)中不包含任何量词
- **普遍有效公式**
  - 如果谓词公式对于它的任一解释下真值都为真，则称该公式为普遍有效公式(永真式)
  - 如果谓词公式对于它的某一个解释下真值都为真，则称该谓词公式为可满足公式
  - 如果谓词公式对于它的任何一个解释下真值都为假，则称该公式为不可满足公式（永假式）
- **谓词等值公式**
  - 对于谓词公式A,B，如果在A,B的任一个解释下，A和B都有相同的真值，则称A和B是等值公式，即为A   B或者A=B
- **谓词蕴涵公式**
  - 对于谓词公式A和B，如果所有使A成真的解释必使B成真，则称谓词公式A蕴涵谓词公式B，或者A永真蕴涵B，记为A⇒B。显然，A⇒B当且仅当A→ B为普遍有效公式
- **量词的消去和引入规则**
  - 全称量词消去规则：∀xP(x) ⇒P(y)，其中y是论域中的任何一个个体
  - 全称量词引入规则：P(y) ⇒∀xP(x)，其中y是论域中的任何一个个体
  - 存在量词消去规则：∃xP(x) ⇒P(c)，其中c是论域中的一个个体常元
  - 存在量词引入规则：P(c) ⇒∃xP(x)，其中c是论域中的一个个体常元
- **直接证明法**
  - 类似于命题逻辑，谓词演算中的直接证明法就是利用前提和等值公式，蕴涵公式的演绎证明。谓词演算过程中，需要消去和引入量词
- **谓词逻辑演算**
  - 谓词演算就是从谓词公式形式的前提出发，推出结论的过程。对于谓词公式P1，P2,…,Pn和Q，如果存在P1∧P2∧…∧Pn⇒Q,则称Q为P1，P2,…,Pn的逻辑结论，记为P1，P2,…,Pn├Q
- **归纳证明法**
  - 是命题演算中归纳推理法的推广。谓词演算中子句集S的建立以及对S的归纳略有不同
  - 对于谓词演算A├B，如何消去G=A∧¬B中的量词，特别是存在量词，是建立字句集S的关键
    - 将S化为等值的前束范式
    - 将该前束范式中存在量词消去，得到仅含全称量词的公式G‘（G‘和G在不可满足的意义下是一致的，从而对G的不可满足性，可由G’的不可满足性来求得）
    - 将G‘中的全称量词省略，并求取G’的合取范式，得到G‘的字句集S
    - 对S的归结中，要进行恰当的变元置换。例如，C1=P(x) ∨Q(x)和C2=¬P(a) ∨R(y)中P(x)和¬P(a)，在置换σ={x/a}下将变元x换成a，变为互补对，可以归结，有归结式Q(a) ∨R(y)
- **谓词演算的基本永真公式**
  - 命题演算的永真公式也是谓词演算的永真公式
  - 含有量词的谓词演算的基本永真公式
    - ¬∀xφ-||-∃x ¬φ
    - ¬∃xφ-||-∀x ¬φ

  - 假设x在ψ中不是自由的，那么：
    - ∀xφ∧ψ-||-∀x(φ∧ψ)
    - ∀xφ∨ψ-||-∀x(φ∨ψ)
    - ∃xφ∧ψ-||-∃x(φ∧ψ)
    - ∃xφ∨ψ-||-∃x(φ∨ψ)
    - ∀x(ψ→φ)-||-ψ→∀xφ
    - ∃x(φ→ψ)-||-∀xφ→ψ
    - ∀x(φ→ψ)-||- ∃xφ→ψ
    - ∃x(ψ→φ)-||- ψ→∃xφ
    - ∀xφ∨∀xψ-||- ∀x(φ∨ψ)
    - ∃xφ∨∃xψ-||- ∃x(φ∨ψ)

## 谓词逻辑语义

- 语义和证明论的区别
  - 证明论中，证明ψ不是Γ的推导结果比证明Γ|-ψ是有效的要困难。(考虑每个可能的证明，说明它不是所需的证明)
  - 语义证明ψ不是Γ的推导结果比证明Γ|-ψ是有效的要容易。(找一个模型使Фi为真，而ψ为假)
- 谓词逻辑语义
  - 谓词逻辑的解释
  - 指定一个论域D
  - 对A中出现的每一个n元函数，指定一个D上的n元个体函数常量
  - 对A中出现的每一个n元谓词，指定一个D上的n元谓词常量
  - 对A中出现的每一个个体常量及自由变元，指定D中的一个个体常量
- 对A中出现的每一个命题变元P，指定一个真值T或F	由此得到一个命题A1，称A1的真值为合适公式A在解释I下的真值
- 模型：假设Γ是函数符号的集合，Ρ是谓词符号的集合，每个符号所需要的变量个数是固定的。符号对(Γ,Ρ)的一个模型Μ是由下面的数据组成的
  - 非空集合A是具体值的全集
  - 对每个零元函数f∈Γ，A中有一个具体元素f^m
  - 对每个元素为n>0的f∈Γ，从集合A上n元集合A^n到A的具体函数fm:A^n→A
  - 对每个n>0元谓词P∈Ρ，A上n元子集Ρ^m:包含于A^n
- 环境：给定一个模型M，可以讨论谓词逻辑公式的真假，但对于存在量词的谓词公式，需要验证模型里的所有的或者某个值
  - 增加一个环境函数来描述
    - 变量集var到A的函数l：var→A   
    - l（x→a）:将x映到a并且将其它变量y映到l（y）
- 谓词逻辑语义定义
  - 给定关于对(Γ,Ρ)的模型M和环境l,对于(Γ,Ρ)上的每个逻辑公式Ф，通过对Ф的结构归纳定义一个满足关系M|=Ф,若M|=Ф成立，则称在模型M中，相对于环境l，Ф的赋值为T。
  - P：如果Ф的形式为P(t1, t2,…, tn),则在集合A中将t1, t2,…, tn解释为：把所有变量根据l的值代替。对每项计算a1, a2,…, an的值，其中任何函数符号f∈Γ通过f^m来解释。 M|= P(t1, t2,…, tn)成立当且仅当a1, a2,…, an∈P^m
  - ∀x：关系M|=∀xψ成立当且仅当M|=l(x→a) ψ对所有a∈A都成立
  - ∃x：关系M|=∃xψ成立当且仅当M|=l(x→a) ψ对某个a∈A成立
  - ¬：关系M|=¬ψ成立当且仅当M|=ψ不成立
  - ∨：关系M|=ψ1∨ψ2成立当且仅当关系M|=ψ1或者关系M|=ψ2成立
  - ∧：关系M|=ψ1 ∧ψ2成立当且仅当关系M|=ψ1和关系M|=ψ2都成立
  - →：关系M|=ψ1 →ψ2成立当且仅当关系M|=ψ1成立则关系M|=ψ2成立
- 语义推导：设Γ使谓词逻辑中的公式的集合，ψ是谓词逻辑公式
  - 语义推导Γ|=ψ成立当且仅当对所有的模型M和环境l，对所有的Ф∈Γ，M|= Ф都成立，则M|=ψ也成立
  - 公式ψ是可满足的当且仅当存在某个模型M和环境l，使得M|=ψ成立
  - 公式ψ是有效的当且仅当在我们能够检测ψ的所有模型M和环境l中， M|=ψ成立
  - 集合Γ是一致的或可满足的当且仅当存在一个模型M和一个环境l，使得对所有的公式Ф∈Γ，M|= Ф成立

## 谓词逻辑的不可判断性

- 在谓词逻辑中，对所有的公式Ф都有效的机械化程序是无法提供的

- 判断问题：它的解是一个程序,将问题的实例作为输入，并且总是可终止的，产生一个正确的“是”或“非”的输出
- 谓词逻辑的判断问题：给定谓词逻辑中一个逻辑公式Ф，|=是否成立？
- 定理：谓词逻辑中的有效性判定问题是不可判定的↔️不存在对任意给定的Ф，判定|=是否成立的程序
- 用问题归约法证明：选择一个已知是不可解的问题，然后用现在问题的可解性推出被选择问题的可解性。波斯特对应问题
- 波斯特对应问题
  - 已知有限序列对(s1 ,t1), (s2 ,t2),…, (sk ,tk),其中si ,ti都是正长度的二进制字符串。是否存在下标序, i1 ,i2 ,…,in (n≧1)，使得字符串的串联si1 ,si2 ,…,sin = ti1 ,ti2 ,…,tin 。
  - 例C=((1,101),(10,00),(011,11))
    s1 =1,    s2 ,=10 , s3 =011    t1 =101, t2 ,=00 ,   t3 =11
    解：1，3，2，3↔️101110011



# 时态逻辑

## 模态逻辑

- 命题逻辑和谓词逻辑表达的可能性：真和假
  不能表达的可能性：必然为真、知道为真、将来为真、相信为真

- 模态（Modal）：谓词逻辑的扩展形式。基于命题逻辑的扩展称为模态命题逻辑，基于一阶谓词逻辑的扩展称为模态一阶逻辑。特点是通过引入“可能”和“必然”两个模态词，从而能够对可能世界中的命题进行描述和演算。

- 模态词：必然（□）；可能（◇）
  例如,对于命题P:火星上有生命
  □P：火星上必然有生命
  ◇P：火星上可能有生命

- 模态命题逻辑公式

  - 原子命题是模态命题逻辑公式
  - 如果A是模态命题逻辑公式，那么□A和◇A是模态命题逻辑公式
  - 如果A,B是模态命题逻辑合适公式，那么(¬A)，(A→B)，(A↔B)，(A∧B)，(A∨B)是模态命题逻辑公式
  - 当且仅当有限次地使用上述所组成的符号串是模态命题逻辑公式

- 模态一阶逻辑公式

  - 原子谓词公式是模态逻辑公式
  - 如果A,B是模态一阶逻辑公式，那么(□A)，(◇A)，(¬A)，(A→B)，(A↔B)，(A∧B)，(A∨B)是模态逻辑公式
  - 如果A是模态一阶逻辑公式，x是A中出现的变量(个体变量)，则∀x.A, ∃x.A是模态逻辑公式
  - 当且仅当有限次地使用上述所组成的符号串是模态一阶逻辑公式

- 模态逻辑语义

  - 要区分真值的不同模式或程度

  - 基本模态逻辑的模型（Kripke）：三元组M=（W,R,L）

    - W：可能世界的非空集合

    - R包含于 W ×W：可能世界W上的二元关系

    - L：W→2^p(P为原子公式集合)：标记函数，对可能世界的真值指派

  - 用图来表现Kripke结构
    ![](https://raw.githubusercontent.com/CorneliusDeng/Markdown-Photos/main/Discrete%20Mathematics/Time%20Logic%201.png)
    - 圆圈：可能世界
    - 有向线段：可能世界之间的关系
    - 圆圈内：标记函数标识（该可能世界中成立的原子公式）

- 标准模型：满足下面条件的三元组M=(W,R,L)：对于p，q∈ P和s，t∈ W有

  - L(p,s)  =  1∨0
  - L(¬p,s)  =  ¬L(p,s)
  - L(p∨q,s) = L(p,s)∨L(q,s)
  - L(p∧q,s) = L(p,s) ∧L(q,s)
  - L(□p,s)  = (∀t)(sRt→L(p,t))=1
  - L(◇p,s)  = (∃t)(sRt→L(p,t))=1

- 定义Ф的真值：设M=(W,R,L)是基本模态逻辑的一个模型，假设x∈W且Ф是模态逻辑公。通过对Ф结构归纳，定义满足关系x||- Ф来定义在世界x中,Ф的真值

  - x||-p当且仅当p∈L(x)
  - x||-¬Ф当且仅当x |≠ Ф
  - x||-Ф∧ψ当且仅当x |= Ф并且x|=ψ
  - x||-Ф∨ψ当且仅当x |= Ф或x|=ψ
  - x||-Ф→ψ当且仅当只要x |= Ф则x|=ψ
  - x||- □ψ当且仅当对R(x,y)的每一y∈W,有y|=ψ
  - x||- ◇ψ当且仅当存在y∈W,使得R(x,y)且y|=ψ

- 如果该模型中每个世界都满足该公式，称基本模态逻辑的模型M(W,R,L)满足一个公式。写M|=Ф当且仅当对每个x∈W,x||-Ф 

- 模态公式之间的等价

  - 基本模态逻辑的一个公式集Γ语义导出基本模态逻辑公式ψ，如果对任何模型M=（W,R,L）中的任何世界x，只要对所有Ф∈Γ均满足x||-Ф,就有x||-ψ 。在这种情况下,Γ|=ψ成立
  - Ф和ψ是语义等价，如果Ф|=ψ和ψ|=Ф成立，记为Ф ≡ ψ
  - 命题逻辑中的任何等价也是模态逻辑中的等价
  - 取命题逻辑中的任何等价，将原子一致地代换成任意的模态逻辑公式，结果还是模态逻辑中的等价

- 有效公式

  - 基本模态公式Ф称为有效，如果它在任何模型的任何世界中都为真
  - 任何命题逻辑重言式是有效公式，它的任何代换实例也是有效公式

## 时态逻辑概述

- 时态逻辑是一种特殊类型的模态逻辑
- 将Kripke结构M=(W,R,L)中的R解释为时间的先后关系的模态逻辑
- 基于对时间的不同描述，产生了多种不同形式的时态逻辑：分支时态逻辑、线性时态逻辑
- 分支时态逻辑
  - 分支时间
    时间具有分支或者树形结构性质：任一当前时刻可能分叉为多种可能未来时间
  - 分支时态逻辑
    - 采用分支时间结构的时态逻辑
    - 需要提供对分支时间特性下多种未来行为描述的量化词
    - 可以很好地处理不确定性
- 线性时态逻辑
  - 线性时间
    任一当前时刻仅存在唯一的可能未来时刻，时间的推进
  - 线性时态逻辑
    - 采用线性时间结构的时态逻辑
    - 提供了用于描述事件沿着单一时间轴演化的模态演算子
- 常用时态逻辑
  - 命题线性时态逻辑（PLTL）
  - 一阶线性时态逻辑（FOLTL）
  - 命题分支时态逻辑或计算树逻辑（CTL，CTL*）
- LTL模型
  - 一个迁移系统M=(S,→,L)是一个状态的集合S，带有迁移关系→，使得每个s∈S有某个s’∈S,满足s→s’，以及一个标记函数L：S→2^p(p是原子式原子式)
    ![](https://raw.githubusercontent.com/CorneliusDeng/Markdown-Photos/main/Discrete%20Mathematics/Time%20Logic%201.png)
  - 路径：模型M=(S,→,L)中的一条路径是S中状态的无限序列s1, s2, s3, …，对每个i≧1，有s_i→s_(i+1)，写为： s1→s2→…
    ![](https://raw.githubusercontent.com/CorneliusDeng/Markdown-Photos/main/Discrete%20Mathematics/Time%20Logic%202.png)
- LTL公式的语义
  - 设M=(S,→,L)是一个模型， π=s1→…是M中的一条路径π|= Ф 【路径π 满足LTL公式Ф】
  - π|= p，p∈Lb(s1)
  - π|= ￢Ф，π|≠ Ф
  -  π|= Ф∨ψ，π|= Ф或者π|= ψ
  -  π|= Ф ∧ ψ，π|= Ф 并且π|= ψ 
  - π|= XФ，π1 |= Ф
  - π|= FФ ，在k≧0，π^k|=Ф 
  - π|= GФ ，对于任意的i≧1，π^i|=Ф 
  - π|= ФUψ，存在i≧1，使得π^i|=ψ且对于所有的j=1,…i-1,有π^j|=Ф 
  - 设M=(S,→,L)是一个模型，s∈S,且每条始于s的执行路径π，都有π|=Ф。记为W.s|=Ф
  - 设M=(S,→,L)是一个模型，s∈S,且Ф是一个LTL公式。如果对M的每条始于s的执行路径π，都有π|= Ф，记为M,s|= Ф
    ![](https://raw.githubusercontent.com/CorneliusDeng/Markdown-Photos/main/Discrete%20Mathematics/Time%20Logic%203.png)
- 规范的实际模式
  - 在started成立但在ready不成立时，不可能到达的状态
    G ¬(started∧ ¬ready)
  - 对任何状态，如果一个请求发生，那么它将最终被确认
    G(requested→F acknowledged)
  - 在每一条计算路径上，一个特定的使能无限多次
    GF enabled
  - 不管发生什么情况，一个特定过程的最终被永远死锁
    FG deadlock
  - 如果该过程被使能无限次，则它运行无限次
    GF enabled→GF running
  - 如果乘客想去五层，一个上行的电梯在第二层不改变方向
    G(floor2∧directionup∧ButtonPressed5→(directionupUfloor5))
- LTL不能表达的性质
  - 从任何状态出发，都可能到达一个重启状态
  - 电梯可以闲置在第三层不开门
- LTL公式之间的重要等价
  - 两个LTL公式Ф和ψ是等价的，如果对所有模型M及M中的所有路径π：π|= Ф当且仅当π|= ψ
  - ￢G Ф ≡ F￢Ф
  - ￢F Ф ≡ G￢Ф
  - ￢X Ф ≡ X￢Ф
  - F(Ф∨ψ) ≡ FФ∨Fψ
  - G(Ф∧ψ) ≡ GФ∧Gψ

## 命题线性时态逻辑(PLTL)

- **在命题逻辑中增加4类模态词**
  - **□(G)演算子**
     **□A：A总是为真或者永远为真**
  - **◇(F)演算子**
    **◇A：A最终为真或者有时为真**
  - **○(X)演算子**
    **○A：A在下一时刻为真**
  - **▽(U)演算子**
    **A▽B：A一直为真直到B为真**
- PLTL公式的定义
  - 原子命题是PLTL
  - 如果A,B是PLTL公式，那么(¬A)，(A→B)，(A↔B)，(A∧B)，(A∨B)是命题线性时态逻辑公式
  - 如果A，B是PLTL公式，那么(□A）)，(◇A)，(○A)，(A▽B)是命题线性时态逻辑公式
  - 当且仅当有限次地使用上述所组成的符号串是PLTL公式
- 示例
  - A→□B	
    如果当前状态A为真，则最终能出现B为真的状态
  - □(A→◇B)	
    从当前状态开始，使A为真的状态后终将有使B为真的状态
  - ◇□A	
    从某一状态开始A永远为真
  - ◇(A∧○¬A)	
    终将有一状态，在该状态中A为真，并且下一状态中A为假
  - □◇A	
    对今后任何状态而言，其后都将有状态使A为真
  - □(A→□B)
    对今后状态而言，A真将导致B从此永远真
  - □A∨(A▽B)
    或者A从此永远真，或者A从此一直真直到使B真的状态出现
  - ▽A→(¬A▽B)	
    如果有状态使A为真，那么必将有一状态，使A在此状态前一直为假，而B在此状态中为真
  - □A→○□A	
    如果A从此永远真，那么下一状态中，A将永远为真

## 一阶线性时态逻辑(FOLTL)

- 一阶线性时态逻辑（FOLTL）是一阶谓词逻辑的扩展，它是在一阶谓词逻辑中增加了模态词
  - □演算子： □A表示A总是为真或者永远为真
  - ◇演算子 ：◇A表示A最终为真或者有时为真
  -  ○演算子： ○A表示A在下一时刻为真
  -  ▽演算子： A▽B表示A一直为真直到B为真
- FOLTL公式的定义
  - 原子谓词公式是FOLTL
  - 如果A,B是FOLTL公式，那么(¬A)，(A→B)，(A↔B)，(A∧B)，(A∨B)是一阶线性时态逻辑公式
  - 如果A是FOLTL公式，x是A中出现的变量，则则∀xA, ∃xA是FOLTL公式
  - 如果A是FOLTL公式，那么(□A)，(◇A)，(○A)，(A▽B)是一阶线性时态逻辑公式
  - 当且仅当有限次地使用上述所组成的符号串是FOLTL公式
- FOLTL的应用
  - 队列及其操作
  - 操作规划问题

## 计算树逻辑(CTL，CTL*)

- 计算树逻辑

  - 一种离散，分支时间命题时态逻辑，由E.Clark和A. Emerson于二十世纪八十年代提出
  - 后来经过对CTL文法中的路径量词及其他时态算子的组合使用进行扩展，建立了CTL*
  - 一般把CTL和CTL*统称为计算树逻辑

- **计算树逻辑演算子：除了时态演算子G，F，X，U外，还增加了路径量词（A：所有未来路径，E：至少一条路径）**

- CTL公式定义

  - 原子命题（命题常元或者命题变元）是CTL
  - 如果φ，ψ是CTL公式，那么(¬φ)，(φ→ψ)，(φ↔ψ)，(φ∧ψ)，(φ∨ψ)是CTL公式
  - 如果φ，ψ是CTL公式，那么(AXφ)，(EXφ)，(A(φUψ))，(E(φUψ))，(AFφ)，(EFφ)，(AGφ)，(EGφ)是CTL公式
  - 当且仅当有限次地使用上述所组成的符号串是CTL公式

- 属于CTL公式的符号串

  - AG(p→EGq)
  - EFE(pUq)
  - EFEGp→AFq
  - A(pUEFq)
  - AGAF(p→A(pU(¬p∧A(¬pUq))))

- 不属于CTL公式的符号串

  - EFGp
    F，G后面必须紧接A或者E
  - EF（pUq）  	
    U必须接A或者E
  - AF((pUq)∧(pUt)) 
     (pUq)，(pUt)前面必须是A或E
  - A((pUq)∧(pUt)) 
    A后面的括号里边不能有∧

- CTL公式的语义：设M=(S,→,L)是关于CTL的一个模型，s∈S，φ是一个CTL公式，关系M,s|=φ由对φ做结构归纳定义

  1. M,s ╞ p当且仅当∈L(s)
  2. M,s |=￢Ф当且仅当 M,s |≠ Ф 
  3. M,s |= Ф∨ψ当且仅当 M,s |= Ф或者M,s |= ψ 
  4. M,s |= Ф ∧ ψ当且仅当 M,s |= Ф 并且M,s |= ψ 
  5.  M,s |= Ф→ψ当且仅当M,s |≠ Ф或者M,s |= ψ
  6. M,s ╞AXφ当且仅当对所有使s→s1的s1有M, s1 |=φ
  7. M,s ╞EXφ当且仅当对某个使s→s1的s1有M, s1 |=φ
  8. M,s ╞AGφ当且仅当对所有满足s=s1的路径s1→s2→ …,及该路径上所有的si有M, si |=φ
  9. M,s ╞ EGφ当且仅当存在一条满足s=s1的路径s1→s2→ …,及该路径上所有的si有M, si |=φ
  10. M,s ╞ AFφ当且仅当对所有满足s=s1的路径s1→s2→ …,，有某个si，使得M, si |=φ
  11. M,s ╞ EFφ当且仅当存在一条满足s=s1的路径s1→s2→ …,，并且该路径存在某个si，使得M, si |=φ
  12.  M,s ╞ A(φ1Uφ2)当且仅当对所有满足s=s1的路径s1→s2→ …,，该路径满足φ1Uφ2，即沿着该路径存在某个si，使得M, si |=φ2；对于每个j<i,有M, sj |=φ1
  13. M,s ╞ E(φ1Uφ2)当且仅当存在一条满足s=s1的路径s1→s2→ …,，该路径满足φ1Uφ2，即沿着该路径存在某个si，使得M, si |=φ2,对于每个j<I,有M, sj |=φ1

  上述满足关系式中，(1)(2)(3)(4)(5)是命题逻辑公式的解释，只需要考察当前状态下公式的满足
  (6)(7)(8)(9)(10)(11)(12)的解释，不仅要考虑当前状态及所关联的直接有序状态，而且要考虑与当前状态所关联的间接后续状态

- 模型的有向图

  - AGφ , EGφ 的路径图

    ![](https://raw.githubusercontent.com/CorneliusDeng/Markdown-Photos/main/Discrete%20Mathematics/Time%20Logic%204.png)

  - AFφ, EFφ的路径图
    ![](https://raw.githubusercontent.com/CorneliusDeng/Markdown-Photos/main/Discrete%20Mathematics/Time%20Logic%205.png)

- 示例：Kripke结构满足的CTL公式
  ![](https://raw.githubusercontent.com/CorneliusDeng/Markdown-Photos/main/Discrete%20Mathematics/Time%20Logic%206.png)

  - M,s0 ╞ p∧q
  - M,s0 ╞ ¬r
  - M,s0 ╞ EX(q∧r)
  - M,s0 ╞ ¬AX(q∧r)
  - M,s0 ╞ ¬EF(p∧r)
  - M,s2 ╞ EGr 
  - M,s2 ╞ AGr
  - M,s0 ╞ E((p∧q)Ur)
  - M,s0 ╞ A(pUq)

- 使用CTL公式描述简单的规格模式

  - EF(start∧¬ready)	
    一个启动started成立但就绪ready不成立的状态
  - AG(requested→AFacknowledged)	
    对于一个状态，如果请求requesed出现，则终将出现应答acknowledged
  - AG(AFenabled) 	
    某一进程在所有路径上都会是使能enable无限次
  - AF(AGdeadlock) 	
    一进程将最终进入死锁
  - AG(EFrestart)	
    任一状态都能进入重启状态
  - AG（floor=2∧direction=up∧ButtonPressed5 →A(direction=upUfloor=5)）
    一部上行电梯中在第二层不改变方向，如果有乘客想去第五层
  - AG(floor=3 ∧idle∧door=close →EG(floor=3∧idle∧door=closed))	
    电梯可以在第三层关着门保持闲置
  - AG(n1→EXt1)
    一个进程总可以进入其关键段
  - EF(c1∧E(c1U(￢c1∧E(￢c2Uc1)))) 
    进程无需按严格顺序进入其关键段

- CTL公式间的重要等价

  - ￢AFФ≡EG￢Ф
  - ￢EFФ≡AG￢Ф
  - ￢AXФ≡EX￢Ф
  - AG Ф≡Ф∧AXAGФ
  - EG Ф≡Ф∧EXEGФ
  - AF Ф≡Ф∧AXAFФ
  - EF Ф≡Ф∧EX EFФ
  - A(ФUψ) Ф≡ψ∨(Ф∧AXA (ФUψ) )
  - E(ФUψ) Ф≡ψ∨(Ф∧EXE (ФUψ) )

- LTL和CTL

  - CTL使用路径量词，在路径描述中比LTL有更强的表达能力
  - CTL不允许像LTL那样，通过公式描述来选择一个路径范围
  - 在CTL的文法中，对路径量词及其他时态演算子，命题连接词的组合使用进行了一定的限制，从而也就限制了其描述能力。CTL*的描述能力超过CTL（除去CTL对每个时态演算子必须与唯一路径量词伴随使用的约束）

- CTL*状态公式定义

  - 原子命题是状态公式如果φ，ψ是状态公式，那么(¬φ)，(φ∧ψ)是CTL公式
  - 如果α是路径公式，那么(Aα)，(Eα)是状态公式
  - 当且仅当有限次地使用上述所组成的符号串是状态公式

- CTL*路径公式定义

  - 状态公式是路经公式
  - 如果α，β是路径公式，那么(¬α)，(α∧β)是路径公式
  - 如果α，β是路径公式，那么(Fα)，(Gα)，(Xα)，(αUβ)是路径公式
  - 当且仅当有限次地使用上述所组成的符号串是路径公式

- CTL*，CTL和LTL的表达能力

  - 不包含路径量词A和E的CTL*公式就是LTL公式
  - 因此，CTL和LTL都可以看为CTL*的子类
    ![](https://raw.githubusercontent.com/CorneliusDeng/Markdown-Photos/main/Discrete%20Mathematics/Time%20Logic%207.png)
